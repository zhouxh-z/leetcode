## jvm 的内存模型
1、堆：new 出来类信息、实例变量、final修饰的局部变量
2、栈帧：运行时产生的 局部变量；
3、本地方法区：native 方法对象信息存放区域
4、方法区：常量、静态变量、类信息
5、程序计数器

## 类加载过程，以及加载出来的信息存放再哪儿
类加载 --- 加载到方法区  
    1、加载：将类信息 class文件 加载到方法区中
    2、验证：验证是否合法
    3、准备：静态变量分配内存空间并赋值 - 赋予对象类型的默认值
    4、解析：将加载到方法区的 class 文件中的（类、方法、变量）引用，修改为 实际内存地址；
    5、初始化：静态变量赋值（真实代码中显示声明的值），执行静态代码块
分配内存 --- 在堆中划一块和对象大小相同的区域，用于存储对象（通过逃逸分析，逃逸的对象存储在栈中）

初始化内存空间 --- 把内存中分配给对象存储的这块空间，初始化（指针碰撞，空闲列表）；

设置对象头 --- 8位

执行init方法 --- 给对象其他属性进行赋值，调用对象的构造器

## GC 垃圾回收
### 垃圾回收的过程是什么，什么时候触发垃圾回收
分类：
young GC(新生代GC):
  过程：
    1、eden区（8） + survivor区 (1+1),对象优先分配在eden区，然后在eden满的情况下触发 => young GC => 将eden 和 survivor区 的存活对象复制到另一块survivor区
    2、survivor区 存活的对象年龄 + 1；
    3、survivor区 分代年龄达到 15，复制到老年代
  触发条件：
    eden满的情况下触发
  算法：复制算法，直接复制存活对象到另一块区域
major GC（老年代GC）:
  过程：
    1、在老年代中，查询所有root对象（STW）
    2、从root对象出发，查找所有链条上的存活对象（并发查找），标记非存活对象；
    3、最终标记，将运行过程中产生的对象，进行标记（STW），原因是第2步，没有STW,用户线程仍在执行，会产生新的对象和新的垃圾；
    4、回收过程和下次young GC 一起触发
  触发条件：
    堆内存使用率超过设置值（默认45%），开启标记；
  算法：标记-整理
full GC(全局GC):
  过程：
    1、STW
    2、对整个堆进行垃圾回收，在堆内存中查询所有root对象
    3、从root对象开始向下查询所有非存活对象，将存活对象移动到一端，初始化其他区域
  触发条件：
    老年代因为各种原因不够用，显式调用system.gc()；
  算法：标记-整理

### 三色标记法
1、将所有对象都设置为白色；
2、将root对象标记为灰色，然后向下扫描，每次完成下级的扫描（将引用的对象设置灰色），将父节点设置为黑色
3、然后在遍历灰色对象，循环2的过程。
4、最后回收白色对象

缺点：黑色下新增的对象，被灰色断开时，会被漏标，导致黑色引用的新对象被回收；

怎么解决：G1 的 解决方法 => 在初始化垃圾会回收前，会打快照，在检查到 并发标记阶段 对象引用发生变更时，会将这个变更对应的“快照引用”写入一个队列中，然后进行最终标记时，会遍历这个队列重新标记
        缺点：浮动垃圾，
        优点：更快，不用追踪新的引用

### 为什么用 G1,优点是什么
1、内存的空间相对连续，减少对象分配时内存碎片问题；
2、并发GC,降低STW的时间
3、降低了Full GC 出现的概率；（标记整理，减少因为内存碎片导致的大对象保存不下问题）
4、GC时间相对可控，可以配置gc时间，优先回收能在时间范围内完成的区域；

### jvm 参数及调优
1、堆的初始化大小
2、调整新、老代的比例
3、线程栈的大小

### jvm 排查方法
1、jstat -gc 排查GC的情况，主要看垃圾回收的情况；
2、jmap -dump 打印内存文件，本地通过 jvisualvm 排查内存溢出情况（引用链）；
3、top 可以查询 cpu、内存等情况；
4、jstack 可以查询 线程情况；

### 内存泄露
是指对象被创建后，无法被回收的情况；
1、静态变量中的集合，一直加，不清空
2、数据库连接、io 等连接未关闭；
3、threadLocal 未清空；

