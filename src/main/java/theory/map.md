# HASHMAP的组成
数组+链表（1.8后 + 红黑树）

# hashmap put 数据的全流程
1、初始化 map，生成一个默认长度的数组；
2、判断这个key写入到数组的哪个位置（key值怎么定位）
3、如果这个位置之前没数据，直接new一个node节点加入
4、如果有数据与链表的根节点对比，判断是否是同一个key，如果相同则替换（怎么判断是否同一个key）
5、如果有数据且不是同一个key，在原来的链表后面加上新的节点
6、如果链表的长度大于8，判断链表长度是否小于64，小于64则优先扩容，否则转换红黑树；（hashmap 怎么扩容）（怎么转红黑树）

## key值怎么定位
hash = key 的hashcode  异或  key 的hashcode 右移 16位
hash & 数组长度-1 可以得出一个 0 到 数组长度-1 这个区间的数；

## 怎么判断是否同一个key
1、先对比hash值是否一致；
2、对比 key 是否 == || 是否 equals 相等 

## 什么时候用链表，什么时候用红黑树
当数组长度大于64，且链表长度大于8，就会转换成红黑树
数组长度小于64，且链表长度大于8，会进行扩容；

## hashmap 怎么扩容
1、生成一个新的数组，数组长度是原来的2倍；
2、判断 链表中数据hash & 原数组长度，生成两串链表；
3、把这两个新的链表 分别加入到 原数组下标位置 以及 原数组位置下标 + 扩容出来的长度 

## 链表怎么转红黑树


# hashmap 默认长度
初始化生成的hashmap 默认 数组长度 16
负载系数是：0.75

## 什么时候进行扩容
1、数组长度达到负载系数*数组长度是进行扩容
2、链表长度 大于等于7

# hashmap 线程不安全 , ConcurrentHashMap 为什么是线程安全的（jdk1.8之后），结合 hashmap  put 数据的全流程
volatile 对node节点 和  node 的val 属性进行修饰，确保多线程环境下的可见性，以及顺序性
1、 ConcurrentHashMap 再初始化时通过 unsafe 类 通过cas进行初始化队列；
2、 如果数组中没有这个key的hash，则通过cas添加一个节点；
3、 如果数组中有这个key的hash，则通过 synchronized 对链表或者红黑树进行加锁；



